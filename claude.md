# FlowerBI

This is a collection of packages that together provide the client and server-side support for generating OLAP-style queries against a SQL database.

The user provides a YAML-based description of their database schema so that FK relationships are known. From this, helper files can be generated by command-line tools which provides calling code with declarations of all the table columns names.

Queries are specified in a `QueryJson` object, and can specify columns to group by, columns to aggregate using `Sum`, `Avg`, etc. and also filters on column values that can be specified at the whole query level or on specific aggregation functions. The column names are always qualified in the form `tablename.columnname` as they can refer to any table in the YAML schema; the joining logic automatically forms the necessary joins between tables.

By default the joins use `INNER JOIN`, but optionally `FULL JOIN` can be requested. These are the only two options because it ensures the joins are commutative and associate, so there is no significance to the order in which the joins are stated in the resulting SQL query.

## Conversion from C#

There is currently an effort underway to replace the C#Â portion of the codebase with a TypeScript equivalent that must be a perfectly compatible drop-in replacement. The way the client code uses the library is:

-   specify a YAML string describing the schema, and a SQL formatter implementation
-   get back an object with a `query` method that accepts a `QueryJson` object, and can be used to generate queries against that schema
-   the generated query includes the SQL string and an object giving any parameters that need to be used with the SQL
-   after executing the query, the schema object can also have helper methods that interpret the result to produce a `QueryResultJson`.

The C# package will be retained but will be a wrapper that uses the `Jint` package to execute a JS bundle generated from the TypeScript.

The source directories are named after their target runtimes:

-   `dotnet` - C# codebase
-   `js` - TypeScript codebase

Key to this effort are the extensive execution tests which generate queries and run them against real Microsoft SQL Server and SQLite databases.

The C# version defined the basic structures such as `QueryJson` and `QueryResultJson` so they used pascal-case property names, as is usual in CLR packages. However, it supported camel-case names in the JSON-persisted equivalent text, and thus camel-case is the standard "wire" format for this package.

The TypeScript replacement code needs to follow the norms of the JS world and use camel-case property names. This will match the wire format.

The migration effort should be focused on eliminating any remaining incompatibilities, and adding tests where appropriate to verify that compatibility has been achieved. Also C# code that overlaps with the new TypeScript equivalent should be replaced by calling into the Jint bundle.

## Migration Status

The TypeScript migration has been substantially completed with the following achievements:

-   **Core Implementation**: `@flowerbi/query-generation` package provides a complete TypeScript implementation
-   **Demo Site Conversion**: Successfully migrated from Bootsharp WASM (`@flowerbi/engine`) to pure TypeScript
-   **ES Module Compatibility**: Packages built as ES modules for modern JavaScript environments
-   **CamelCase Conversion**: All interfaces and types converted to camelCase naming conventions
-   **YAML Schema Parsing**: Custom SimpleYamlParser handles variable indentation and inheritance

## Package Architecture

-   **`@flowerbi/query-generation`**: Pure TypeScript implementation (core library)
-   **`@flowerbi/engine`**: Bootsharp WASM wrapper around C# code (legacy, replaced in demo)
-   **`@flowerbi/client`**: Client-side TypeScript definitions and utilities
-   **`demo-site`**: React-based demonstration using SQLite WASM

## Critical Implementation Details

### YAML Schema Inheritance

Tables using `extends` inherit the parent table's database name (`NameInDb`), not their own YAML key:

```yaml
Coder:
    id:
        Id: [int]
    columns:
        FullName: [string]

CoderAssigned:
    extends: Coder # Maps to database table "Coder"

CoderResolved:
    extends: Coder # Also maps to database table "Coder"
```

Both `CoderAssigned` and `CoderResolved` generate SQL referencing the `Coder` table, allowing multiple logical table definitions to share a single physical database table.

### Type Compatibility

There are type incompatibilities between legacy and new implementations:

-   **Enum Values**: Old implementation uses string literals (`"Count"`), new uses enums (`AggregationType.Count`)
-   **Property Names**: Legacy PascalCase vs new camelCase
-   **Solution**: Type casting is used in bridge code to maintain compatibility

### ES Module Requirements

TypeScript packages must be built as ES modules when consumed by modern bundlers:

-   Set `"type": "module"` in package.json
-   Use `"module": "ESNext"` in tsconfig.json
-   Add `"moduleResolution": "node"` for proper import resolution

### Date Parameter Handling

A critical issue with JavaScript Date parameter serialization: `Date.toISOString()` converts to UTC, which can change the actual date:

```javascript
// Local date in PST (UTC-8)
const date = new Date('2023-01-01T23:00:00'); // 11 PM local time
date.toISOString().split('T')[0]; // "2023-01-02" - WRONG! Next day in UTC

// Correct approach - use local date components
const year = date.getFullYear();
const month = String(date.getMonth() + 1).padStart(2, '0'); 
const day = String(date.getDate()).padStart(2, '0');
const localDateString = `${year}-${month}-${day}`; // "2023-01-01" - CORRECT!
```

This is handled in `QueryEngine.convertParameter()` to ensure date filters work correctly across timezones.

## Known Edge Cases

1. **YAML Indentation**: The custom parser requires consistent indentation levels within each nesting context
2. **Extends Inheritance**: Database table names must be inherited correctly for foreign key relationships to work
3. **Enum Compatibility**: Careful type casting needed when bridging between old and new type definitions
4. **Date Parameter Serialization**: JavaScript Date objects must be converted to database-compatible strings (YYYY-MM-DD format) using local date components to avoid UTC timezone conversion issues that could shift the date

## Testing Gaps Identified

The migration revealed some test coverage gaps:

-   **Extends inheritance for database table names** was not fully tested
-   **Complex YAML indentation scenarios** needed more coverage
-   **Type compatibility edge cases** between implementations
-   **Date parameter handling** with different database engines

## Issues with demo-site

This now directly references `@flowerbi/query-generation`. Part of it is working (the "Playground" query editor), but the "Bug Tracking" demo page seemingly never returns from the SQLite call.

# Important Instruction Reminders

Do what has been asked; nothing more, nothing less.
NEVER create files unless they're absolutely necessary for achieving your goal.
ALWAYS prefer editing an existing file to creating a new one.
NEVER proactively create documentation files (\*.md) or README files. Only create documentation files if explicitly requested by the User.
