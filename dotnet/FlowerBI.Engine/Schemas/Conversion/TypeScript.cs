using System.Collections.Generic;
using System.IO;
using System.Linq;
using FlowerBI.Yaml;

namespace FlowerBI.Conversion;

public static class TypeScript
{
    static (string Decl, string Cls) TSColumnType(DataType dataType, bool nullable)
    {
        var jsType = dataType switch
        {
            DataType.Bool => "boolean",
            DataType.String => "string",
            DataType.DateTime => "Date",
            _ => "number",
        };
        if (nullable)
        {
            jsType = $"{jsType} | null";
        }

        return jsType == "string" ? ($"StringQueryColumn<{jsType}>", "StringQueryColumn")
            : jsType != "number" ? ($"QueryColumn<{jsType}>", "QueryColumn")
            : dataType is DataType.Decimal or DataType.Float or DataType.Double
                ? ($"NumericQueryColumn<{jsType}>", "NumericQueryColumn")
            : ($"IntegerQueryColumn<{jsType}>", "IntegerQueryColumn");
    }

    public static void FromYaml(string yamlFile, string tsFile, TextWriter console) =>
        FromSchema(File.ReadAllText(yamlFile), tsFile, console);

    static void FromSchema(string yamlText, string tsFile, TextWriter console)
    {
        using var writer = new WriteIfDifferent(tsFile, console);

        FromSchema(yamlText, writer.Output, writer.Console);
    }

    public static void FromSchema(string yamlText, TextWriter outputWriter, TextWriter console)
    {
        var schema = ResolvedSchema.Resolve(yamlText);

        var imports = new HashSet<string>(["QueryColumnRuntimeType", "QueryColumnDataType"]);

        var writer = new StringWriter();

        writer.WriteLine("// Important: this file is auto-generated by flowerbi.");
        writer.WriteLine();

        var tableWriter = new IndentedWriter(writer);

        foreach (var table in schema.Tables)
        {
            console.WriteLine($"Exporting table {table.Name}");
            writer.WriteLine($"export const {table.Name} = {{");

            var idColumn =
                table.IdColumn != null
                    ? new[] { table.IdColumn }
                    : Enumerable.Empty<ResolvedColumn>();

            string GetTargetString(ResolvedColumn column) =>
                column == null ? "" : $"{column.Table.Name}.{column.Name}";

            foreach (var column in idColumn.Concat(table.Columns))
            {
                var (tsType, importType) = TSColumnType(column.DataType, column.Nullable);
                imports.Add(importType);

                tableWriter.WriteLine(
                    $"""
                    {column.Name}: new {tsType}("{table.Name}.{column.Name}",
                        new QueryColumnRuntimeType(
                            QueryColumnDataType.{column.DataType},
                            "{GetTargetString(column.Target)}"
                        )
                    ), 
                    """
                );
            }

            writer.WriteLine("};");
            writer.WriteLine();
        }

        writer.WriteLine($"export const {schema.Name} = {{");
        foreach (var table in schema.Tables)
        {
            tableWriter.WriteLine(@$"{table.Name},");
        }
        writer.WriteLine("};");

        writer.WriteLine("export const yaml = `");

        var yamlWriter = new IndentedWriter(writer);
        foreach (var line in yamlText.Split('\n'))
        {
            yamlWriter.WriteLine(line.TrimEnd());
        }
        yamlWriter.WriteLine("`;");

        writer.Flush();

        if (imports.Count != 0)
        {
            outputWriter.WriteLine(
                @$"import {{ {string.Join(", ", imports.OrderBy(x => x))} }} from ""@flowerbi/client"";"
            );
            outputWriter.WriteLine();
        }

        outputWriter.Write(writer.ToString());

        outputWriter.Flush();

        console.WriteLine("Done.");
    }
}
