import { ResolvedSchema, ResolvedColumn, DataType } from '../schema/YamlSchemaTypes';
import { SchemaResolver } from '../schema/SchemaResolver';
import { IndentedWriter } from './IndentedWriter';

/**
 * Generates TypeScript code from YAML schema definitions
 * Equivalent to the C# TypeScript.cs generator
 */
export class TypeScriptGenerator {
  
  /**
   * Determine TypeScript column type information from DataType
   */
  private static getColumnType(dataType: DataType, nullable: boolean): { 
    declaration: string; 
    className: string; 
  } {
    let jsType: string;
    
    switch (dataType) {
      case DataType.Bool:
        jsType = 'boolean';
        break;
      case DataType.String:
        jsType = 'string';
        break;
      case DataType.DateTime:
        jsType = 'Date';
        break;
      default:
        jsType = 'number';
        break;
    }

    if (nullable) {
      jsType = `${jsType} | null`;
    }

    // Determine column class based on type
    let className: string;
    if (jsType.includes('string')) {
      className = 'StringQueryColumn';
    } else if (jsType !== 'number') {
      className = 'QueryColumn';
    } else {
      // For numeric types, distinguish between integer and floating point
      if (dataType === DataType.Decimal || dataType === DataType.Float || dataType === DataType.Double) {
        className = 'NumericQueryColumn';
      } else {
        className = 'IntegerQueryColumn';
      }
    }

    return {
      declaration: `${className}<${jsType}>`,
      className: className
    };
  }

  /**
   * Get target string for foreign key relationships
   */
  private static getTargetString(column: ResolvedColumn | undefined): string {
    return column ? `${column.Table.Name}.${column.Name}` : '';
  }

  /**
   * Generate TypeScript code from YAML schema text
   */
  static fromYaml(yamlText: string): { code: string; console: string } {
    const consoleOutput: string[] = [];
    
    try {
      const schema = SchemaResolver.resolve(yamlText);
      const code = TypeScriptGenerator.fromSchema(schema, yamlText, consoleOutput);
      
      return {
        code,
        console: consoleOutput.join('\n')
      };
    } catch (error) {
      consoleOutput.push(`Error: ${error instanceof Error ? error.message : String(error)}`);
      return {
        code: '',
        console: consoleOutput.join('\n')
      };
    }
  }

  /**
   * Generate TypeScript code from a resolved schema
   */
  private static fromSchema(
    schema: ResolvedSchema, 
    yamlText: string, 
    consoleOutput: string[]
  ): string {
    const imports = new Set<string>(['QueryColumnRuntimeType', 'QueryColumnDataType']);
    const writer = new IndentedWriter();
    const output: string[] = [];
    
    // Header comment
    output.push('// Important: this file is auto-generated by flowerbi.');
    output.push('');

    // Generate table exports
    for (const table of schema.Tables) {
      consoleOutput.push(`Exporting table ${table.Name}`);
      
      output.push(`export const ${table.Name} = {`);
      
      // Collect all columns (ID + regular columns)
      const allColumns: ResolvedColumn[] = [];
      if (table.IdColumn) {
        allColumns.push(table.IdColumn);
      }
      allColumns.push(...table.Columns);

      // Generate column definitions
      for (const column of allColumns) {
        const { declaration, className } = TypeScriptGenerator.getColumnType(
          column.DataType, 
          column.Nullable
        );
        imports.add(className);

        const targetString = TypeScriptGenerator.getTargetString(column.Target);
        
        writer.writeLine(
          `${column.Name}: new ${declaration}("${table.Name}.${column.Name}",`
        );
        writer.writeLine(
          `    new QueryColumnRuntimeType(`
        );
        writer.writeLine(
          `        QueryColumnDataType.${column.DataType},`
        );
        writer.writeLine(
          `        "${targetString}"`
        );
        writer.writeLine(
          `    )`
        );
        writer.writeLine(
          `),`
        );
      }

      output.push(writer.toString());
      writer.clear();
      output.push('};');
      output.push('');
    }

    // Generate schema export
    output.push(`export const ${schema.Name} = {`);
    for (const table of schema.Tables) {
      writer.writeLine(`${table.Name},`);
    }
    output.push(writer.toString());
    writer.clear();
    output.push('};');
    output.push('');

    // Generate YAML export
    output.push('export const yaml = `');
    const yamlLines = yamlText.split('\n');
    for (const line of yamlLines) {
      writer.writeLine(line.trimEnd());
    }
    output.push(writer.toString());
    writer.clear();
    output.push('`;');

    // Prepare final output with imports
    const finalOutput: string[] = [];
    
    if (imports.size > 0) {
      const sortedImports = Array.from(imports).sort();
      finalOutput.push(
        `import { ${sortedImports.join(', ')} } from "@flowerbi/client";`
      );
      finalOutput.push('');
    }

    finalOutput.push(...output);
    
    consoleOutput.push('Done.');
    
    return finalOutput.join('\n');
  }

  /**
   * Generate TypeScript code from YAML file path
   */
  static fromYamlFile(yamlText: string): string {
    const result = TypeScriptGenerator.fromYaml(yamlText);
    return result.code;
  }
}